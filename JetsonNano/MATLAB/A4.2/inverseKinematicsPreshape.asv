function [motorAngles] = inverseKinematicsPreshape(desiredPosition,normStableLine)




%Set length values for all links in model
linkLengtha = 25;
linkLengthb = 95;
linkLengthc = 60;
linkLengthd = 35;

%Set the posistion of motor M3 relative to the center of the palm
motorPositionM3 = [60,60];
%Make the direction relate to M3 position instead of palm center
directionPosition = normStableLine - motorPositionM3;
%If the directionPosition is the same as motorPositionM3 move the direction
%in the normal direction
if directionPosition == 0
    directionPosition = normStableLine + desiredPosition - motorPositionM3;
end
%Calcualet the angle that motor M3 should move to
motorAngles(1) = angle(directionPosition(1) + directionPosition(2)*1i);


if motorAngles(1) < 0
    motorAngles(1) = abs(motorAngles(1));
if  motorAngles(1) > (pi/2)
    motorAngles(1) = motorAngles(1) - pi;

end

motorPositionM1 = [60,60]; %Calculate actaul position
motorPositionM2 = motorPositionM1 + [29 -38];


distanceX = desiredPosition(1) - motorPositionM1(1);
distanceY = desiredPosition(2) - motorPositionM1(2);

distance = sqrt( distanceX^2 + distanceY^2 );

motorAngles(2) = pi/2 - acos(distance / linkLengthc);
if distanceX >= 0 && distanceY >= 0
    motorAngles(2) = -motorAngles(2);
end

motorAngles(3) = parallelMotorAnglet2(motorAngles(2),motorPositionM1,motorPositionM2,linkLengtha,linkLengthb,linkLengthc,linkLengthd);

motorAngles = int16(rad2deg(motorAngles) * 65535 / 359);



end